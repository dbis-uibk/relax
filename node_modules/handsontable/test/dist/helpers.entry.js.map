{"version":3,"file":"helpers.entry.js","sources":["webpack:///webpack/bootstrap fe732bf3a16958fe7b68","webpack:///test/helpers/index.js","webpack:///external \"window\"","webpack:///test/helpers/common.js","webpack:///test/helpers/jasmine.js","webpack:///test/helpers/asciiTable.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 81);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fe732bf3a16958fe7b68","/* eslint-disable import/no-unresolved */\nimport window from 'window';\nimport * as common from './common';\nimport * as jasmine from './jasmine';\n\nconst exportToWindow = (helpersHolder) => {\n  Object.keys(helpersHolder).forEach((key) => {\n    if (key === '__esModule') {\n      return;\n    }\n\n    if (window[key] !== void 0) {\n      throw Error(`Cannot export \"${key}\" helper because this name is already assigned.`);\n    }\n\n    window[key] = helpersHolder[key];\n  });\n};\n\n// Export all helpers to the window.\nexportToWindow(common);\nexportToWindow(jasmine);\n\n\n\n// WEBPACK FOOTER //\n// test/helpers/index.js","module.exports = window;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"window\"\n// module id = 82\n// module chunks = 1","export function sleep(delay = 100) {\n  return Promise.resolve({\n    then: function(resolve) {\n      setTimeout(resolve, delay);\n    }\n  });\n};\n\nexport function promisfy(fn) {\n  return new Promise((resolve, reject) => fn(resolve, reject));\n};\n\nexport function hot() {\n  return spec().$container.data('handsontable');\n};\n\nexport function handsontable(options) {\n  var currentSpec = spec();\n\n  currentSpec.$container.handsontable(options);\n  currentSpec.$container[0].focus(); // otherwise TextEditor tests do not pass in IE8\n\n  return currentSpec.$container.data('handsontable');\n};\n\n/**\n * As for v. 0.11 the only scrolling method is native scroll, which creates copies of main htCore table inside of the container.\n * Therefore, simple $(\".htCore\") will return more than one object. Most of the time, you're interested in the original\n * htCore, not the copies made by native scroll.\n *\n * This method returns the original htCore object\n *\n * @returns {jqObject} reference to the original htCore\n */\n\nexport function getHtCore() {\n  return spec().$container.find('.htCore').first();\n};\n\nexport function getTopClone() {\n  return spec().$container.find('.ht_clone_top');\n};\n\nexport function getTopLeftClone() {\n  return spec().$container.find('.ht_clone_top_left_corner');\n};\n// for compatybility\n// var getCornerClone = getTopLeftClone;\n\nexport function getLeftClone() {\n  return spec().$container.find('.ht_clone_left');\n};\n\nexport function getBottomClone() {\n  return spec().$container.find('.ht_clone_bottom');\n};\n\nexport function getBottomLeftClone() {\n  return spec().$container.find('.ht_clone_bottom_left_corner');\n};\n\n// Rename me to countTD\nexport function countCells() {\n  return getHtCore().find('tbody td').length;\n};\n\nexport function isEditorVisible() {\n  return !!(keyProxy().is(':visible') && keyProxy().parent().is(':visible') && !keyProxy().parent().is('.htHidden'));\n};\n\nexport function isFillHandleVisible() {\n  return !!spec().$container.find('.wtBorder.corner:visible').length;\n};\n\nexport function getCorrespondingOverlay(cell, container) {\n  var overlay = $(cell).parents('.handsontable');\n\n  if (overlay[0] == container[0]) {\n    return $('.ht_master');\n  }\n\n  return $(overlay[0]);\n};\n\n/**\n * Shows context menu\n */\nexport function contextMenu(cell) {\n  var hot = spec().$container.data('handsontable');\n  var selected = hot.getSelectedLast();\n\n  if (!selected) {\n    hot.selectCell(0, 0);\n    selected = hot.getSelectedLast();\n  }\n  if (!cell) {\n    cell = getCell(selected[0], selected[1]);\n  }\n  var cellOffset = $(cell).offset();\n\n  $(cell).simulate('mousedown', { button: 2 });\n  $(cell).simulate('contextmenu', {\n    clientX: cellOffset.left - Handsontable.dom.getWindowScrollLeft(),\n    clientY: cellOffset.top - Handsontable.dom.getWindowScrollTop(),\n  });\n  $(cell).simulate('mouseup', { button: 2 });\n};\n\nexport function closeContextMenu() {\n  $(document).simulate('mousedown');\n  // $(document).trigger('mousedown');\n};\n\n/**\n * Shows dropdown menu\n */\nexport function dropdownMenu(columnIndex) {\n  var hot = spec().$container.data('handsontable');\n  var th = hot.view.wt.wtTable.getColumnHeader(columnIndex || 0);\n  var button = th.querySelector('.changeType');\n\n  if (button) {\n    $(button).simulate('mousedown');\n    $(button).simulate('click');\n  }\n};\n\nexport function closeDropdownMenu() {\n  $(document).simulate('mousedown');\n};\n\nexport function dropdownMenuRootElement() {\n  var plugin = hot().getPlugin('dropdownMenu');\n  var root;\n\n  if (plugin && plugin.menu) {\n    root = plugin.menu.container;\n  }\n\n  return root;\n};\n\n/**\n * Returns a function that triggers a mouse event\n * @param {String} type Event type\n * @return {Function}\n */\nexport function handsontableMouseTriggerFactory(type, button) {\n  return function(element) {\n    if (!(element instanceof jQuery)) {\n      element = $(element);\n    }\n    var ev = $.Event(type);\n    ev.which = button || 1; // left click by default\n\n    element.simulate(type, ev);\n  };\n};\n\nexport const mouseDown = handsontableMouseTriggerFactory('mousedown');\nexport const mouseMove = handsontableMouseTriggerFactory('mousemove');\nexport const mouseOver = handsontableMouseTriggerFactory('mouseover');\nexport const mouseUp = handsontableMouseTriggerFactory('mouseup');\n\nexport function mouseDoubleClick(element) {\n  mouseDown(element);\n  mouseUp(element);\n  mouseDown(element);\n  mouseUp(element);\n};\n\nexport const mouseRightDown = handsontableMouseTriggerFactory('mousedown', 3);\nexport const mouseRightUp = handsontableMouseTriggerFactory('mouseup', 3);\n\n/**\n * Returns a function that triggers a key event\n * @param {String} type Event type\n * @return {Function}\n */\nexport function handsontableKeyTriggerFactory(type) {\n  return function(key, extend) {\n    var ev = {}; // $.Event(type);\n\n    if (typeof key === 'string') {\n      if (key.indexOf('shift+') > -1) {\n        key = key.substring(6);\n        ev.shiftKey = true;\n      }\n\n      if (key.indexOf('ctrl+') > -1) {\n        key = key.substring(5);\n        ev.ctrlKey = true;\n        ev.metaKey = true;\n      }\n\n      switch (key) {\n        case 'tab':\n          ev.keyCode = 9;\n          break;\n\n        case 'enter':\n          ev.keyCode = 13;\n          break;\n\n        case 'esc':\n          ev.keyCode = 27;\n          break;\n\n        case 'f2':\n          ev.keyCode = 113;\n          break;\n\n        case 'arrow_left':\n          ev.keyCode = 37;\n          break;\n\n        case 'arrow_up':\n          ev.keyCode = 38;\n          break;\n\n        case 'arrow_right':\n          ev.keyCode = 39;\n          break;\n\n        case 'arrow_down':\n          ev.keyCode = 40;\n          break;\n\n        case 'ctrl':\n          if (window.navigator.platform.includes('Mac')) {\n            ev.keyCode = 91;\n          } else {\n            ev.keyCode = 17;\n          }\n          break;\n\n        case 'shift':\n          ev.keyCode = 16;\n          break;\n\n        case 'backspace':\n          ev.keyCode = 8;\n          break;\n\n        case 'delete':\n          ev.keyCode = 46;\n          break;\n\n        case 'space':\n          ev.keyCode = 32;\n          break;\n\n        case 'x':\n          ev.keyCode = 88;\n          break;\n\n        case 'c':\n          ev.keyCode = 67;\n          break;\n\n        case 'v':\n          ev.keyCode = 86;\n          break;\n\n        case 'a':\n          ev.keyCode = 65;\n          break;\n\n        default:\n          throw new Error(`Unrecognised key name: ${key}`);\n      }\n    } else if (typeof key === 'number') {\n      ev.keyCode = key;\n    }\n    //    ev.originalEvent = {}; //needed as long Handsontable searches for event.originalEvent\n    $.extend(ev, extend);\n    $(document.activeElement).simulate(type, ev);\n  };\n};\n\nexport const keyDown = handsontableKeyTriggerFactory('keydown');\nexport const keyUp = handsontableKeyTriggerFactory('keyup');\n\n/**\n * Presses keyDown, then keyUp\n */\nexport function keyDownUp(key, extend) {\n  if (typeof key === 'string' && key.indexOf('shift+') > -1) {\n    keyDown('shift');\n  }\n\n  keyDown(key, extend);\n  keyUp(key, extend);\n\n  if (typeof key === 'string' && key.indexOf('shift+') > -1) {\n    keyUp('shift');\n  }\n};\n\n/**\n * Returns current value of the keyboard proxy textarea\n * @return {String}\n */\nexport function keyProxy() {\n  return spec().$container.find('textarea.handsontableInput');\n};\n\nexport function serveImmediatePropagation(event) {\n  if (event != null && event.isImmediatePropagationEnabled == null) {\n    event.stopImmediatePropagation = function() {\n      this.isImmediatePropagationEnabled = false;\n      this.cancelBubble = true;\n    };\n    event.isImmediatePropagationEnabled = true;\n    event.isImmediatePropagationStopped = function() {\n      return !this.isImmediatePropagationEnabled;\n    };\n  }\n\n  return event;\n};\n\nexport function autocompleteEditor() {\n  return spec().$container.find('.handsontableInput');\n};\n\n/**\n * Sets text cursor inside keyboard proxy\n */\nexport function setCaretPosition(pos) {\n  var el = keyProxy()[0];\n\n  if (el.setSelectionRange) {\n    el.focus();\n    el.setSelectionRange(pos, pos);\n  } else if (el.createTextRange) {\n    var range = el.createTextRange();\n    range.collapse(true);\n    range.moveEnd('character', pos);\n    range.moveStart('character', pos);\n    range.select();\n  }\n};\n\n/**\n * Returns autocomplete instance\n */\nexport function autocomplete() {\n  return spec().$container.find('.autocompleteEditor');\n};\n\n/**\n * Triggers paste string on current selection\n */\nexport function triggerPaste(str) {\n  spec().$container.data('handsontable').getPlugin('CopyPaste').paste(str);\n};\n\n/**\n * Calls a method in current Handsontable instance, returns its output\n * @param method\n * @return {Function}\n */\nexport function handsontableMethodFactory(method) {\n  return function() {\n    var instance;\n    try {\n      instance = spec().$container.handsontable('getInstance');\n    } catch (err) {\n      console.error(err);\n    }\n\n    if (instance) {\n      if (method === 'destroy') {\n        spec().$container.removeData();\n      }\n    } else {\n      if (method === 'destroy') {\n        return; // we can forgive this... maybe it was destroyed in the test\n      }\n      throw new Error('Something wrong with the test spec: Handsontable instance not found');\n    }\n\n    return instance[method](...arguments);\n  };\n};\n\nexport const addHook = handsontableMethodFactory('addHook');\nexport const alter = handsontableMethodFactory('alter');\nexport const colToProp = handsontableMethodFactory('colToProp');\nexport const countCols = handsontableMethodFactory('countCols');\nexport const countEmptyCols = handsontableMethodFactory('countEmptyCols');\nexport const countEmptyRows = handsontableMethodFactory('countEmptyRows');\nexport const countRows = handsontableMethodFactory('countRows');\nexport const countSourceCols = handsontableMethodFactory('countSourceCols');\nexport const countSourceRows = handsontableMethodFactory('countSourceRows');\nexport const deselectCell = handsontableMethodFactory('deselectCell');\nexport const destroy = handsontableMethodFactory('destroy');\nexport const destroyEditor = handsontableMethodFactory('destroyEditor');\nexport const emptySelectedCells = handsontableMethodFactory('emptySelectedCells');\nexport const getActiveEditor = handsontableMethodFactory('getActiveEditor');\nexport const getCell = handsontableMethodFactory('getCell');\nexport const getCellEditor = handsontableMethodFactory('getCellEditor');\nexport const getCellMeta = handsontableMethodFactory('getCellMeta');\nexport const getCellMetaAtRow = handsontableMethodFactory('getCellMetaAtRow');\nexport const getCellRenderer = handsontableMethodFactory('getCellRenderer');\nexport const getCellsMeta = handsontableMethodFactory('getCellsMeta');\nexport const getCellValidator = handsontableMethodFactory('getCellValidator');\nexport const getColHeader = handsontableMethodFactory('getColHeader');\nexport const getCopyableData = handsontableMethodFactory('getCopyableData');\nexport const getCopyableText = handsontableMethodFactory('getCopyableText');\nexport const getData = handsontableMethodFactory('getData');\nexport const getDataAtCell = handsontableMethodFactory('getDataAtCell');\nexport const getDataAtCol = handsontableMethodFactory('getDataAtCol');\nexport const getDataAtRow = handsontableMethodFactory('getDataAtRow');\nexport const getDataAtRowProp = handsontableMethodFactory('getDataAtRowProp');\nexport const getDataType = handsontableMethodFactory('getDataType');\nexport const getInstance = handsontableMethodFactory('getInstance');\nexport const getRowHeader = handsontableMethodFactory('getRowHeader');\nexport const getSelected = handsontableMethodFactory('getSelected');\nexport const getSelectedLast = handsontableMethodFactory('getSelectedLast');\nexport const getSelectedRange = handsontableMethodFactory('getSelectedRange');\nexport const getSelectedRangeLast = handsontableMethodFactory('getSelectedRangeLast');\nexport const getSourceData = handsontableMethodFactory('getSourceData');\nexport const getSourceDataArray = handsontableMethodFactory('getSourceDataArray');\nexport const getSourceDataAtCell = handsontableMethodFactory('getSourceDataAtCell');\nexport const getSourceDataAtCol = handsontableMethodFactory('getSourceDataAtCol');\nexport const getSourceDataAtRow = handsontableMethodFactory('getSourceDataAtRow');\nexport const getValue = handsontableMethodFactory('getValue');\nexport const loadData = handsontableMethodFactory('loadData');\nexport const populateFromArray = handsontableMethodFactory('populateFromArray');\nexport const propToCol = handsontableMethodFactory('propToCol');\nexport const removeCellMeta = handsontableMethodFactory('removeCellMeta');\nexport const render = handsontableMethodFactory('render');\nexport const selectAll = handsontableMethodFactory('selectAll');\nexport const selectCell = handsontableMethodFactory('selectCell');\nexport const selectCells = handsontableMethodFactory('selectCells');\nexport const selectColumns = handsontableMethodFactory('selectColumns');\nexport const selectRows = handsontableMethodFactory('selectRows');\nexport const setCellMeta = handsontableMethodFactory('setCellMeta');\nexport const setDataAtCell = handsontableMethodFactory('setDataAtCell');\nexport const setDataAtRowProp = handsontableMethodFactory('setDataAtRowProp');\nexport const spliceCellsMeta = handsontableMethodFactory('spliceCellsMeta');\nexport const spliceCol = handsontableMethodFactory('spliceCol');\nexport const spliceRow = handsontableMethodFactory('spliceRow');\nexport const updateSettings = handsontableMethodFactory('updateSettings');\n\n/**\n * Returns column width for HOT container\n * @param $elem\n * @param col\n * @returns {Number}\n */\nexport function colWidth($elem, col) {\n  var TR = $elem[0].querySelector('TBODY TR');\n  var cell;\n\n  if (TR) {\n    cell = TR.querySelectorAll('TD')[col];\n  } else {\n    cell = $elem[0].querySelector('THEAD TR').querySelectorAll('TH')[col];\n  }\n\n  if (!cell) {\n    throw new Error(`Cannot find table column of index '${col}'`);\n  }\n\n  return cell.offsetWidth;\n}\n\n/**\n * Returns row height for HOT container\n * @param $elem\n * @param row\n * @returns {Number}\n */\nexport function rowHeight($elem, row) {\n  var TD;\n\n  if (row >= 0) {\n    TD = $elem[0].querySelector(`tbody tr:nth-child(${row + 1}) td`);\n  } else {\n    TD = $elem[0].querySelector(`thead tr:nth-child(${Math.abs(row)})`);\n  }\n\n  if (!TD) {\n    throw new Error(`Cannot find table row of index '${row}'`);\n  }\n\n  return Handsontable.dom.outerHeight(TD);\n}\n\n/**\n * Returns value that has been rendered in table cell\n * @param {Number} trIndex\n * @param {Number} tdIndex\n * @returns {String}\n */\nexport function getRenderedValue(trIndex, tdIndex) {\n  return spec().$container.find('tbody tr').eq(trIndex).find('td').eq(tdIndex).html();\n}\n\n/**\n * Returns nodes that have been rendered in table cell\n * @param {Number} trIndex\n * @param {Number} tdIndex\n * @returns {String}\n */\nexport function getRenderedContent(trIndex, tdIndex) {\n  return spec().$container.find('tbody tr').eq(trIndex).find('td').eq(tdIndex).children();\n}\n\n/**\n * Create numerical data values for the table\n * @param rowCount\n * @param colCount\n * @returns {Array}\n */\nexport function createNumericData(rowCount, colCount) {\n  rowCount = typeof rowCount === 'number' ? rowCount : 100;\n  colCount = typeof colCount === 'number' ? colCount : 4;\n\n  var\n    rows = [],\n    i,\n    j;\n\n  for (i = 0; i < rowCount; i++) {\n    var row = [];\n\n    for (j = 0; j < colCount; j++) {\n      row.push((i + 1));\n    }\n    rows.push(row);\n  }\n\n  return rows;\n}\n\n/**\n * Model factory, which creates object with private properties, accessible by setters and getters.\n * Created for the purpose of testing HOT with Backbone-like Models\n * @param opts\n * @returns {{}}\n * @constructor\n */\nexport function Model(opts) {\n  var obj = {};\n\n  var _data = $.extend({\n    id: undefined,\n    name: undefined,\n    address: undefined\n  }, opts);\n\n  obj.attr = function(name, value) {\n    if (typeof value === 'undefined') {\n      return this.get(name);\n    }\n\n    return this.set(name, value);\n  };\n\n  obj.get = function(name) {\n    return _data[name];\n  };\n\n  obj.set = function(name, value) {\n    _data[name] = value;\n\n    return this;\n  };\n\n  return obj;\n}\n/**\n * Factory which produces an accessor for objects of type \"Model\" (see above).\n * This function should be used to create accessor for a given property name and pass it as `data` option in column\n * configuration.\n *\n * @param name - name of the property for which an accessor function will be created\n * @returns {Function}\n */\nexport function createAccessorForProperty(name) {\n  return function(obj, value) {\n    return obj.attr(name, value);\n  };\n}\n\nexport function resizeColumn(displayedColumnIndex, width) {\n  var $container = spec().$container;\n  var $th = $container.find(`thead tr:eq(0) th:eq(${displayedColumnIndex})`);\n\n  $th.simulate('mouseover');\n\n  var $resizer = $container.find('.manualColumnResizer');\n  var resizerPosition = $resizer.position();\n\n  $resizer.simulate('mousedown', {\n    clientX: resizerPosition.left,\n  });\n\n  var delta = width - $th.width() - 2;\n  var newPosition = resizerPosition.left + delta;\n  $resizer.simulate('mousemove', {\n    clientX: newPosition\n  });\n\n  $resizer.simulate('mouseup');\n}\n\nexport function resizeRow(displayedRowIndex, height) {\n  var $container = spec().$container;\n  var $th = $container.find(`tbody tr:eq(${displayedRowIndex}) th:eq(0)`);\n\n  $th.simulate('mouseover');\n\n  var $resizer = $container.find('.manualRowResizer');\n  var resizerPosition = $resizer.position();\n\n  $resizer.simulate('mousedown', {\n    clientY: resizerPosition.top\n  });\n\n  var delta = height - $th.height() - 2;\n\n  if (delta < 0) {\n    delta = 0;\n  }\n\n  $resizer.simulate('mousemove', {\n    clientY: resizerPosition.top + delta\n  });\n\n  $resizer.simulate('mouseup');\n}\n\nexport function moveSecondDisplayedRowBeforeFirstRow(container, secondDisplayedRowIndex) {\n  var\n    $mainContainer = container.parents('.handsontable').not('[class*=clone]').not('[class*=master]').first(),\n    $rowHeaders = container.find('tbody tr th'),\n    $firstRowHeader = $rowHeaders.eq(secondDisplayedRowIndex - 1),\n    $secondRowHeader = $rowHeaders.eq(secondDisplayedRowIndex);\n\n  $secondRowHeader.simulate('mouseover');\n  var $manualRowMover = $mainContainer.find('.manualRowMover');\n\n  if ($manualRowMover.length) {\n    $manualRowMover.simulate('mousedown', {\n      clientY: $manualRowMover[0].getBoundingClientRect().top\n    });\n\n    $manualRowMover.simulate('mousemove', {\n      clientY: $manualRowMover[0].getBoundingClientRect().top - 20\n    });\n\n    $firstRowHeader.simulate('mouseover');\n    $secondRowHeader.simulate('mouseup');\n  }\n}\n\nexport function moveFirstDisplayedRowAfterSecondRow(container, firstDisplayedRowIndex) {\n  var\n    $mainContainer = container.parents('.handsontable').not('[class*=clone]').not('[class*=master]').first(),\n    $rowHeaders = container.find('tbody tr th'),\n    $firstRowHeader = $rowHeaders.eq(firstDisplayedRowIndex),\n    $secondRowHeader = $rowHeaders.eq(firstDisplayedRowIndex + 1);\n\n  $secondRowHeader.simulate('mouseover');\n  var $manualRowMover = $mainContainer.find('.manualRowMover');\n\n  if ($manualRowMover.length) {\n    $manualRowMover.simulate('mousedown', {\n      clientY: $manualRowMover[0].getBoundingClientRect().top\n    });\n\n    $manualRowMover.simulate('mousemove', {\n      clientY: $manualRowMover[0].getBoundingClientRect().top + 20\n    });\n\n    $firstRowHeader.simulate('mouseover');\n    $secondRowHeader.simulate('mouseup');\n  }\n}\n\nexport function swapDisplayedColumns(container, from, to) {\n  var $mainContainer = container.parents('.handsontable').not('[class*=clone]').not('[class*=master]').first();\n  var $colHeaders = container.find('thead tr:eq(0) th');\n  var $to = $colHeaders.eq(to);\n  var $from = $colHeaders.eq(from);\n\n  // Enter the second column header\n  $from.simulate('mouseover');\n  var $manualColumnMover = $mainContainer.find('.manualColumnMover');\n\n  // Grab the second column\n  $manualColumnMover.simulate('mousedown', {\n    pageX: $manualColumnMover[0].getBoundingClientRect().left,\n  });\n\n  // Drag the second column over the first column\n  $manualColumnMover.simulate('mousemove', {\n    pageX: $manualColumnMover[0].getBoundingClientRect().left - 20,\n  });\n\n  $to.simulate('mouseover');\n\n  // Drop the second column\n  $from.simulate('mouseup');\n}\n\nexport function triggerTouchEvent(type, target, pageX, pageY) {\n  var e = document.createEvent('TouchEvent');\n  var targetCoords = target.getBoundingClientRect();\n  var touches;\n  var targetTouches;\n  var changedTouches;\n\n  if (!pageX && !pageY) {\n    pageX = parseInt(targetCoords.left + 3, 10);\n    pageY = parseInt(targetCoords.top + 3, 10);\n  }\n\n  var touch = document.createTouch(window, target, 0, pageX, pageY, pageX, pageY);\n\n  if (type == 'touchend') {\n    touches = document.createTouchList();\n    targetTouches = document.createTouchList();\n    changedTouches = document.createTouchList(touch);\n  } else {\n    touches = document.createTouchList(touch);\n    targetTouches = document.createTouchList(touch);\n    changedTouches = document.createTouchList(touch);\n  }\n\n  e.initTouchEvent(type, true, true, window, null, 0, 0, 0, 0, false, false, false, false, touches, targetTouches, changedTouches, 1, 0);\n  target.dispatchEvent(e);\n};\n\n\n\n// WEBPACK FOOTER //\n// test/helpers/common.js","import {generateASCIITable} from './asciiTable';\n\n/* eslint-disable import/prefer-default-export */\nvar currentSpec;\n\nexport function spec() {\n  return currentSpec;\n};\n\nfunction hot() {\n  return spec().$container.data('handsontable');\n};\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 15000;\n\n// http://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes\nconst scrollbarWidth = (function calculateScrollbarWidth() {\n  const inner = document.createElement('div');\n\n  inner.style.height = '200px';\n  inner.style.width = '100%';\n\n  const outer = document.createElement('div');\n\n  outer.style.boxSizing = 'content-box';\n  outer.style.height = '150px';\n  outer.style.left = '0px';\n  outer.style.overflow = 'hidden';\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.width = '200px';\n  outer.style.visibility = 'hidden';\n  outer.appendChild(inner);\n\n  (document.body || document.documentElement).appendChild(outer);\n  const w1 = inner.offsetWidth;\n\n  outer.style.overflow = 'scroll';\n\n  let w2 = inner.offsetWidth;\n\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n\n  (document.body || document.documentElement).removeChild(outer);\n\n  return (w1 - w2);\n}());\n\nbeforeEach(function() {\n  currentSpec = this;\n\n  var matchers = {\n    toBeInArray() {\n      return {\n        compare(actual, expected) {\n          return {\n            pass: Array.isArray(expected) && expected.indexOf(actual) > -1\n          };\n        }\n      };\n    },\n    toBeFunction() {\n      return {\n        compare(actual, expected) {\n          return {\n            pass: typeof actual === 'function'\n          };\n        }\n      };\n    },\n    toBeAroundValue() {\n      return {\n        compare(actual, expected, diff) {\n          diff = diff || 1;\n\n          var pass = actual >= expected - diff && actual <= expected + diff;\n          var message = `Expected ${actual} to be around ${expected} (between ${expected - diff} and ${expected + diff})`;\n\n          if (!pass) {\n            message = `Expected ${actual} NOT to be around ${expected} (between ${expected - diff} and ${expected + diff})`;\n          }\n\n          return {\n            pass,\n            message\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the passed cell element is contained in the table viewport.\n     */\n    toBeVisibleInViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const verticalPosition = actual.offsetTop - viewport.scrollTop + scrollbarWidth + actual.clientHeight;\n          const horizontalPosition = actual.offsetLeft - viewport.scrollLeft + scrollbarWidth + actual.clientWidth;\n\n          const pass = verticalPosition < viewport.offsetHeight && verticalPosition > 0\n            && horizontalPosition < viewport.offsetWidth && horizontalPosition > 0;\n\n          return {\n            pass,\n            message: 'Expected the element to be visible in the Handsontable viewport'\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the viewport is scrolled in the way that the cell is visible at the top of the viewport.\n     */\n    toBeVisibleAtTopOfViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const verticalPosition = actual.offsetTop - viewport.scrollTop - 1;\n\n          return {\n            pass: verticalPosition === 0,\n            message: 'Expected the element to be scrolled to the top of the Handsontable viewport'\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the viewport is scrolled in the way that the cell is visible at the bottom of the viewport.\n     */\n    toBeVisibleAtBottomOfViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const verticalPosition = actual.offsetTop - viewport.scrollTop + scrollbarWidth + actual.clientHeight + 1;\n\n          return {\n            pass: verticalPosition === viewport.offsetHeight,\n            message: 'Expected the element to be scrolled to the bottom of the Handsontable viewport'\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the viewport is scrolled in the way that the cell is visible on the left of the viewport.\n     */\n    toBeVisibleAtLeftOfViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const horizontalPosition = viewport.scrollLeft - actual.offsetLeft;\n\n          return {\n            pass: horizontalPosition === 0,\n            message: 'Expected the element to be scrolled to the top of the Handsontable viewport'\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the viewport is scrolled in the way that the cell is visible on the right of the viewport.\n     */\n    toBeVisibleAtRightOfViewport() {\n      return {\n        compare(actual) {\n          const viewport = hot().view.wt.wtTable.holder;\n          const horizontalPosition = viewport.scrollLeft - actual.offsetLeft + actual.clientWidth - scrollbarWidth + 1;\n\n          return {\n            pass: horizontalPosition === viewport.offsetWidth,\n            message: 'Expected the element to be scrolled to the top of the Handsontable viewport'\n          };\n        }\n      };\n    },\n    toBeListFulfillingCondition() {\n      const redColor = '\\x1b[31m';\n      const resetColor = '\\x1b[0m';\n\n      return {\n        compare(checkedArray, conditionFunction) {\n          if (typeof conditionFunction !== 'function') {\n            throw Error('Parameter passed to `toBeListFulfillingCondition` should be a function.');\n          }\n\n          const isListWithValues = Array.isArray(checkedArray) || checkedArray.length > 0;\n          const elementNotFulfillingCondition = checkedArray.find((element) => !conditionFunction(element));\n          const containsUndefined = isListWithValues && checkedArray.includes(undefined);\n          const pass = isListWithValues && !containsUndefined && elementNotFulfillingCondition === undefined;\n          let message;\n\n          if (!isListWithValues) {\n            message = 'Non-empty list should be passed as expect parameter.';\n\n          } else if (containsUndefined) {\n            message = `List ${redColor}${checkedArray.join(', ')}${resetColor} contains ${redColor}undefined${resetColor} value.`;\n\n          } else if (elementNotFulfillingCondition !== undefined) {\n            let entityValue = elementNotFulfillingCondition;\n\n            if (typeof elementNotFulfillingCondition === 'string') {\n              entityValue = `\"${elementNotFulfillingCondition}\"`;\n            }\n\n            message = `Entity ${redColor}${entityValue}${resetColor}, from list: ${redColor}${checkedArray.join(', ')}${resetColor} doesn't satisfy the condition.`;\n          }\n\n          return {\n            pass,\n            message\n          };\n        }\n      };\n    },\n    /**\n     * The matcher checks if the provided selection pattern matches to the rendered cells by checking if\n     * the appropriate CSS class name was added.\n     *\n     * The provided structure should be passed as an array of arrays, for instance:\n     * ```\n     * // Non-contiguous selection (with enabled top and left headers)\n     * expect(`\n     *   |   ║   :   : * : * |\n     *   |===:===:===:===:===|\n     *   | - ║   :   : A : 0 |\n     *   | - ║   : 1 : 0 : 0 |\n     *   | - ║   : 2 : 1 : 0 |\n     *   | - ║   : 2 : 1 : 0 |\n     *   | - ║   : 1 : 1 : 0 |\n     *   | - ║   :   : 0 : 0 |\n     *   `).toBeMatchToSelectionPattern();\n     * // Single cell selection (with fixedRowsTop: 1 and fixedColumnsLeft: 2)\n     * expect(`\n     *   |   :   |   :   :   |\n     *   |---:---:---:---:---|\n     *   |   :   |   :   :   |\n     *   |   :   |   :   :   |\n     *   |   :   | # :   :   |\n     *   |   :   |   :   :   |\n     *   |   :   |   :   :   |\n     *   |   :   |   :   :   |\n     *   `).toBeMatchToSelectionPattern();\n     * ```\n     *\n     * The meaning of the symbol used to describe the cells:\n     * ' ' - An empty space indicates cell which doesn't have added any selection classes.\n     * '0' - The number (from 0 to 7) indicates selected layer level.\n     * 'A' - The letters (from A to H) indicates the position of the cell which contains the hidden editor\n     *       (which `current` class name). The letter `A` indicates the currently selected cell with\n     *       a background of the first layer and `H` as the latest layer (most dark).\n     * '#' - The hash symbol indicates the currently selected cell without changed background color.\n     *\n     * The meaning of the symbol used to describe the table:\n     * ':'   - Column separator (only for better visual looks).\n     * '║'   - This symbol separates the row headers from the table content.\n     * '===' - This symbol separates the column headers from the table content.\n     * '|'   - The symbol which indicates the left overlay edge.\n     * '---' - The symbol which indicates the top overlay edge.\n     */\n    toBeMatchToSelectionPattern() {\n      return {\n        compare(actualPattern) {\n          const asciiTable = generateASCIITable(hot().rootElement);\n\n          const patternParts = (actualPattern || '').split(/\\n/);\n          const redundantPadding = patternParts.reduce((padding, line) => {\n            const trimmedLine = line.trim();\n\n            if (trimmedLine) {\n              const currentPadding = line.search(/\\S|$/);\n\n              if (currentPadding < padding) {\n                padding = currentPadding;\n              }\n            }\n\n            return padding;\n          }, Infinity);\n\n          const normalizedPattern = patternParts.reduce((acc, line) => {\n            const trimmedLine = line.trim();\n\n            if (trimmedLine) {\n              acc.push(line.substr(redundantPadding));\n            }\n\n            return acc;\n          }, []);\n\n          const actualAsciiTable = normalizedPattern.join('\\n');\n          const message = `Expected the pattern selection \\n${actualAsciiTable}\\nto match to the visual state of the rendered selection \\n${asciiTable}\\n`;\n\n          return {\n            pass: asciiTable === actualAsciiTable,\n            message,\n          };\n        }\n      };\n    },\n  };\n\n  jasmine.addMatchers(matchers);\n\n  if (document.activeElement && document.activeElement != document.body) {\n    document.activeElement.blur();\n\n  } else if (!document.activeElement) { // IE\n    document.body.focus();\n  }\n});\n\nafterEach(() => {\n  window.scrollTo(0, 0);\n});\n\n\n\n// WEBPACK FOOTER //\n// test/helpers/jasmine.js","/* eslint-disable import/prefer-default-export */\nconst $ = (selector, context = document) => context.querySelector(selector);\n\n/**\n * Return ASCII symbol for headers depends on what the class name HTMLTableCellElement has.\n *\n * @param {HTMLTableCellElement} cell\n * @return {String} Returns '   ', ` * ` or ' - '.\n */\nfunction getSelectionSymbolForHeader(cell) {\n  const hasActiveHeader = cell.classList.contains('ht__active_highlight');\n  const hasHighlight = cell.classList.contains('ht__highlight');\n\n  let symbol = '   ';\n\n  if (hasActiveHeader) {\n    symbol = ' * ';\n\n  } else if (hasHighlight) {\n    symbol = ' - ';\n  }\n\n  return symbol;\n}\n\n/**\n * Return ASCII symbol for cells depends on what the class name HTMLTableCellElement has.\n *\n * @param {HTMLTableCellElement} cell\n * @return {String} Returns valid symbol for the pariticaul cell.\n */\nfunction getSelectionSymbolForCell(cell) {\n  const hasCurrent = cell.classList.contains('current');\n  const hasArea = cell.classList.contains('area');\n  let areaLevel = new Array(7)\n    .fill()\n    .map((_, i, arr) => `area-${arr.length - i}`)\n    .find((className) => cell.classList.contains(className));\n\n  areaLevel = areaLevel ? parseInt(areaLevel.replace('area-', ''), 10) : areaLevel;\n\n  let symbol = '   ';\n\n  if (hasCurrent && hasArea && areaLevel) {\n    symbol = ` ${String.fromCharCode(65 + areaLevel)} `;\n\n  } else if (hasCurrent && hasArea && areaLevel === void 0) {\n    symbol = ' A ';\n\n  } else if (hasCurrent && !hasArea && areaLevel === void 0) {\n    symbol = ' # ';\n\n  } else if (!hasCurrent && hasArea && areaLevel === void 0) {\n    symbol = ' 0 ';\n\n  } else if (!hasCurrent && hasArea && areaLevel) {\n    symbol = ` ${areaLevel} `;\n  }\n\n  return symbol;\n}\n\n/**\n * Generate ASCII symbol for passed cell element.\n *\n * @param {HTMLTableCellElement} cell\n * @return {String}\n */\nfunction getSelectionSymbol(cell) {\n  if (isLeftHeader(cell) || isTopHeader(cell)) {\n    return getSelectionSymbolForHeader(cell);\n  }\n\n  return getSelectionSymbolForCell(cell);\n}\n\n/**\n * Check if passed element belong to the left header.\n *\n * @param {HTMLTableCellElement} cell\n * @return {Boolean}\n */\nfunction isLeftHeader(cell) {\n  return cell.tagName === 'TH' && cell.parentElement.parentElement.tagName === 'TBODY';\n}\n\n/**\n * Check if passed element belong to the rop header.\n *\n * @param {HTMLTableCellElement} cell\n * @return {Boolean}\n */\nfunction isTopHeader(cell) {\n  return cell.tagName === 'TH' && cell.parentElement.parentElement.tagName === 'THEAD';\n}\n\n/**\n * @param {HTMLTableElement} overlay\n * @return {Function}\n */\nfunction cellFactory(overlay) {\n  return (row, column) => overlay && overlay.rows[row] && overlay.rows[row].cells[column];\n}\n\n/**\n * Generates table based on Handsontable structure.\n *\n * @param {HTMLElement} context The root element of the Handsontable instance to be generated.\n * @return {String}\n */\nexport function generateASCIITable(context) {\n  const TABLE_EDGES_SYMBOL = '|';\n  const COLUMN_SEPARATOR = ':';\n  const ROW_HEADER_SEPARATOR = '\\u2551';\n  const COLUMN_HEADER_SEPARATOR = '===';\n  const ROW_OVERLAY_SEPARATOR = '|';\n  const COLUMN_OVERLAY_SEPARATOR = '---';\n\n  const cornerOverlayTable = $('.ht_clone_top_left_corner .htCore', context);\n  const leftOverlayTable = $('.ht_clone_left .htCore', context);\n  const topOverlayTable = $('.ht_clone_top .htCore', context);\n  const masterTable = $('.ht_master .htCore', context);\n  const stringRows = [];\n\n  const cornerOverlayCells = cellFactory(cornerOverlayTable);\n  const leftOverlayCells = cellFactory(leftOverlayTable);\n  const topOverlayCells = cellFactory(topOverlayTable);\n  const masterCells = cellFactory(masterTable);\n\n  const hasLeftHeader = leftOverlayCells(1, 0) ? isLeftHeader(leftOverlayCells(1, 0)) : false;\n  const hasTopHeader = topOverlayCells(0, 1) ? isTopHeader(topOverlayCells(0, 1)) : false;\n  const hasCornerHeader = hasLeftHeader && hasTopHeader;\n  const hasFixedLeftCells = leftOverlayCells(1, 1) ? !isLeftHeader(leftOverlayCells(1, 1)) : false;\n  const hasFixedTopCells = topOverlayCells(1, 1) ? !isTopHeader(topOverlayCells(1, 1)) : false;\n\n  const consumedFlags = new Map([\n    ['hasLeftHeader', hasLeftHeader],\n    ['hasTopHeader', hasTopHeader],\n    ['hasCornerHeader', hasCornerHeader],\n    ['hasFixedLeftCells', hasFixedLeftCells],\n    ['hasFixedTopCells', hasLeftHeader],\n  ]);\n\n  const rowsLength = masterTable.rows.length;\n\n  for (let r = 0; r < rowsLength; r++) {\n    const stringCells = [];\n    const columnsLength = masterTable.rows[0].cells.length;\n    let isLastColumn = false;\n    let insertTopOverlayRowSeparator = false;\n\n    for (let c = 0; c < columnsLength; c++) {\n      let cellSymbol;\n      let separatorSymbol = COLUMN_SEPARATOR;\n\n      isLastColumn = c === columnsLength - 1;\n\n      if (cornerOverlayCells(r, c)) {\n        const cell = cornerOverlayCells(r, c);\n        const nextCell = cornerOverlayCells(r, c + 1);\n\n        cellSymbol = getSelectionSymbol(cell);\n\n        if (isLeftHeader(cell) && (!nextCell || !isLeftHeader(nextCell))) {\n          separatorSymbol = ROW_HEADER_SEPARATOR;\n        }\n        if (!isLeftHeader(cell) && !nextCell) {\n          separatorSymbol = ROW_OVERLAY_SEPARATOR;\n        }\n        if (r === 0 && c === 0 && hasCornerHeader) { // Fix for header symbol\n          separatorSymbol = ROW_HEADER_SEPARATOR;\n        }\n\n      } else if (leftOverlayCells(r, c)) {\n        const cell = leftOverlayCells(r, c);\n        const nextCell = leftOverlayCells(r, c + 1);\n\n        cellSymbol = getSelectionSymbol(cell);\n\n        if (isLeftHeader(cell) && (!nextCell || !isLeftHeader(nextCell))) {\n          separatorSymbol = ROW_HEADER_SEPARATOR;\n        }\n        if (!isLeftHeader(cell) && !nextCell) {\n          separatorSymbol = ROW_OVERLAY_SEPARATOR;\n        }\n\n      } else if (topOverlayCells(r, c)) {\n        const cell = topOverlayCells(r, c);\n\n        cellSymbol = getSelectionSymbol(cell);\n\n        if (hasFixedTopCells && isLastColumn && !topOverlayCells(r + 1, c)) {\n          insertTopOverlayRowSeparator = true;\n        }\n\n      } else if (masterCells(r, c)) {\n        const cell = masterCells(r, c);\n\n        cellSymbol = getSelectionSymbol(cell);\n      }\n\n      stringCells.push(cellSymbol);\n\n      if (!isLastColumn) {\n        stringCells.push(separatorSymbol);\n      }\n    }\n\n    stringRows.push(TABLE_EDGES_SYMBOL + stringCells.join('') + TABLE_EDGES_SYMBOL);\n\n    if (consumedFlags.get('hasTopHeader')) {\n      consumedFlags.delete('hasTopHeader');\n      stringRows.push(TABLE_EDGES_SYMBOL + new Array(columnsLength).fill(COLUMN_HEADER_SEPARATOR).join(COLUMN_SEPARATOR) + TABLE_EDGES_SYMBOL);\n    }\n    if (insertTopOverlayRowSeparator) {\n      insertTopOverlayRowSeparator = false;\n      stringRows.push(TABLE_EDGES_SYMBOL + new Array(columnsLength).fill(COLUMN_OVERLAY_SEPARATOR).join(COLUMN_SEPARATOR) + TABLE_EDGES_SYMBOL);\n    }\n  }\n\n  return stringRows.join('\\n');\n}\n\n\n\n// WEBPACK FOOTER //\n// test/helpers/asciiTable.js"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5DA;AACA;;;AAAA;AACA;AADA;AACA;AAAA;AACA;AADA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AAoBA;AACA;;;;;;;ACrBA;;;;;;;;;;;ACAA;AAQA;AAIA;AAIA;AAmBA;AAIA;AAIA;AAMA;AAIA;AAIA;AAKA;AAIA;AAIA;AAIA;AAaA;AAqBA;AAQA;AAWA;AAIA;AAgBA;AAiBA;AAeA;AA2GA;AAiBA;AAIA;AAeA;AAOA;AAkBA;AAOA;AASA;AA0FA;AAuBA;AAsBA;AAUA;AAUA;AA4BA;AAqCA;AAMA;AAsBA;AA0BA;AAwBA;AAwBA;AA0BA;AAvsBA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1EA;AA4EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AADA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5tBA;AACA;AANA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAfA;AAiBA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AAbA;AAeA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AATA;AAWA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AATA;AAWA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AATA;AAWA;AACA;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAhCA;AAkCA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AApCA;AAsCA;AArPA;AACA;AAuPA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3MA;AA9GA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}